{"name":"Stately.js","tagline":"Stately.js is a JavaScript based finite-state machine (FSM) engine for Node.js and the browser.","body":"![Stately.js Logo](https://github.com/fschaefer/Stately.js/raw/master/misc/Stately.js.png)\r\n\r\n## What is it?\r\n\r\nStately.js is a JavaScript based finite-state machine (FSM) engine for Node.js\r\nand the browser.\r\n\r\n## Installation\r\n\r\nIn Node.js you can install Stately.js with `npm`:\r\n\r\n    $ npm install stately.js\r\n\r\nand include it to your project by:\r\n\r\n```js\r\nvar Stately = require('stately.js');\r\n```\r\n\r\nAlternately, you can install Stately.js with `bower`:\r\n\r\n    $ bower install --save Stately.js\r\n\r\nIn browsers you can include it directly by adding it to the document head section:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"https://raw.github.com/fschaefer/Stately.js/master/Stately.js\"></script>\r\n<script type=\"text/javascript\">\r\n    // use Stately\r\n</script>\r\n```\r\n\r\nor with Asynchronous Module Definition by e.g.:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"https://raw.github.com/jrburke/requirejs/master/require.js\"></script>\r\n<script type=\"text/javascript\">\r\nrequire(['https://raw.github.com/fschaefer/Stately.js/master/Stately.js'], function (Stately) {\r\n    // use Stately\r\n});\r\n</script>\r\n```\r\n\r\n## Usage\r\n\r\n### Creating a new machine\r\n\r\nA new state machine can be created with either the new operator:\r\n\r\n```js\r\nvar machine = new Stately(statesObject, initialStateName);\r\n```\r\n\r\nor the factory method:\r\n\r\n```js\r\nvar machine = Stately.machine(statesObject, initialStateName);\r\n```\r\n\r\nBoth will return a new `stateMachine` object, with all events from all states\r\nattached to it. The machine will transition into the initial state `initialStateName`\r\n or the first attached `stateObject` if `initialStateName` is omitted. In addition\r\nto the events the `stateMachine` object has a `getMachineState()` method, returning\r\nthe current name of the machines state, `getMachineEvents()`, returning possible\r\nevents in the current state, and `bind()` and `unbind()` methods, to register\r\ncallbacks to receive `notifications` when the machine transitions into another state.\r\n\r\nThe `statesObject` is an object  with `stateObject` objects attached as\r\nproperties.\r\nThe property names of the `statesObject` are the `states` of the machine.\r\nThe attached `stateObject` objects model the machines states with the property\r\nnames as `events` and the connected functions as `actions`:\r\n\r\n```js\r\nvar machine = Stately.machine({\r\n    'STATE0': {\r\n        event: function () {\r\n            ...\r\n        }\r\n    },\r\n    'STATE1': {\r\n        event: function () {\r\n            ...\r\n        }\r\n    },\r\n    'STATE2':{\r\n        event: function () {\r\n            ...\r\n        },\r\n        anotherEvent: function () {\r\n            ...\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nIf different states use the same event identifier, the `events` are chained up\r\nand the machine handles calling the correct `action` for the current state (if\r\nthe `event` is handled in the current state). If the event is not handled in\r\nthe current state, it is ignored.\r\n\r\nIf no immediate `action` needs to be declared, the desired transition `state`\r\ncan be attached to the `event` as string directly:\r\n\r\n```js\r\nvar machine = Stately.machine({\r\n    'STATE0': {\r\n        'event':        /* => */ 'STATE1'\r\n    },\r\n    'STATE1': {\r\n        'event':        /* => */ 'STATE2'\r\n    },\r\n    'STATE2': {\r\n        'event':        /* => */ 'STATE0',\r\n        'anotherEvent': /* => */ 'STATE1'\r\n    }\r\n});\r\n```\r\n\r\n### Transitions\r\n\r\nThere are several ways an `action` can transition the machine into another\r\nstate. The simplest form is returning the desired next state from an action.\r\nTherefore, `this` refers to the (internal) `stateStore` inside an `action` to\r\naccess the other states of the machine:\r\n\r\n```js\r\n...\r\n\r\n'STATE1': {\r\n    doSomething: function () {\r\n\r\n        ...\r\n\r\n        //transition from STATE1 to STATE2\r\n        return this.STATE2;\r\n        // as an alternative just return the new state as string\r\n        // return 'STATE2';\r\n    }\r\n}\r\n\r\n...\r\n```\r\n\r\nIf an action should not transition the machine into another state, just omit\r\nthe return value (or return the current state).\r\n\r\nSometimes it is desired to return a value from an action. In this case the\r\nreturn value must be an array with two elements. The first element is the next\r\nstate the machine should transition into, and the second element the return\r\nvalue:\r\n\r\n```js\r\n...\r\n\r\n'STATE1': {\r\n    doSomething: function () {\r\n\r\n        ...\r\n\r\n        //transition from STATE1 to STATE2 and return a string\r\n        return [this.STATE2, 'this is a return value'];\r\n    }\r\n}\r\n\r\n...\r\n```\r\n\r\nFor asynchronous actions there are `getMachineState()` and\r\n`setMachineState(nextState)` accessible through the `this` reference of an\r\naction:\r\n\r\n```js\r\n...\r\n\r\n'STATE1': {\r\n    doSomething: function () {\r\n        var self = this;\r\n\r\n        setTimeout(function () {\r\n\r\n            ...\r\n\r\n            self.setMachineState(self.STATE2);\r\n        }, 5000);\r\n\r\n        ...\r\n\r\n    }\r\n}\r\n\r\n...\r\n```\r\n\r\nBecause `this` refers to the `stateStore`, it is also possible to call an\r\naction from another state (note: this won't trigger the `notification`\r\ncallbacks):\r\n\r\n```js\r\n...\r\n\r\n'STATE1': {\r\n    doSomething: function () {\r\n\r\n        ...\r\n\r\n        this.STATE2.doSomethingDifferent.call(this);\r\n\r\n        ...\r\n\r\n        return this.STATE3.doSomethingCompletelyDifferent.call(this);\r\n    }\r\n}\r\n\r\n...\r\n```\r\n\r\n### Notifications\r\n\r\nOnce in a while, it is useful to get a `notification` when the machine\r\ntransitions into another state. Therefore the `stateMachine` object has\r\n`bind(callback)` and `unbind(callback)` to register and unregister notification\r\nhandlers that get called when the state changes. A notification callback has\r\nthe following form:\r\n\r\n```js\r\nfunction notification (event, oldState, newState) {\r\n    ...\r\n}\r\n```\r\n\r\n`event` - The event that triggered the transition.\r\n`oldState` - The old state the machine is transitioned from.\r\n`newState` - The new state the machine is transitioned into.\r\n\r\nInside the `notification`, `this` refers to the internal `stateStore`.\r\n\r\n### Hooks\r\n\r\nBeside the notification system via `bind` and `unbind`, there is an alternative\r\nway to attach hooks that are triggered when the state of the machine changes.\r\nPossible hooks are `onenterSTATE` (or as shortcut `onSTATE`)\r\nand `onleaveSTATE` for states and `onbeforeEVENT` and `onafterEVENT` for\r\nevents. Hook functions have the same signature as notifications bound with\r\n`bind`.\r\n\r\n## Examples\r\n\r\n### Door\r\n\r\n```js\r\nvar door = Stately.machine({\r\n    'OPEN': {\r\n        'close':  /* => */ 'CLOSED'\r\n    },\r\n    'CLOSED': {\r\n        'open':   /* => */ 'OPEN',\r\n        'lock':   /* => */ 'LOCKED'\r\n    },\r\n    'LOCKED': {\r\n        'unlock': /* => */ 'CLOSED',\r\n        'break':  /* => */ 'BROKEN'\r\n    },\r\n    'BROKEN': {\r\n        'fix': function () {\r\n            this.fixed = (this.fixed === undefined ? 1 : ++this.fixed);\r\n            return this.fixed < 3 ? this.OPEN : this.BROKEN;\r\n        }\r\n    }\r\n});\r\n\r\n//the initial state of the door is open (it's the first state object)\r\nconsole.log(door.getMachineState() === 'OPEN');        // true;\r\n\r\n//close and lock the door\r\ndoor.close().lock();\r\nconsole.log(door.getMachineState() === 'LOCKED');      // true;\r\n\r\n//try to open it\r\ndoor.open();\r\nconsole.log(door.getMachineState() === 'OPEN');        // false;\r\n\r\n//unlock, open, lock (is ignored because it fails), close, and lock\r\ndoor.unlock().open().lock().close().lock();\r\nconsole.log(door.getMachineState() === 'LOCKED');      // true;\r\n\r\n//the door is still locked, break it\r\ndoor.break();\r\nconsole.log(door.getMachineState() === 'BROKEN');      // true;\r\n\r\n//fix opens the door, close it, lock it, break it again\r\ndoor.fix().close().lock().break();\r\nconsole.log(door.getMachineState() === 'BROKEN');      // true;\r\n\r\n//and again fix opens the door, close it, lock it, break it\r\ndoor.fix().close().lock().break();\r\nconsole.log(door.getMachineState() === 'BROKEN');      // true;\r\n\r\n//fixing is limited, the door stays broken\r\ndoor.fix();\r\nconsole.log(door.getMachineState() === 'OPEN');        // false;\r\nconsole.log(door.getMachineState() === 'BROKEN');      // true;\r\n```\r\n\r\n### Radio\r\n\r\n```js\r\nvar radio = Stately.machine({\r\n    'STOPPED': {\r\n        play: function () {\r\n            return this.PLAYING;\r\n        }\r\n    },\r\n    'PLAYING': {\r\n        stop: function () {\r\n            return this.STOPPED;\r\n        },\r\n        pause: function () {\r\n            return this.PAUSED;\r\n        }\r\n    },\r\n    'PAUSED': {\r\n        play: function () {\r\n            return this.PLAYING;\r\n        },\r\n        stop: function () {\r\n            return this.STOPPED;\r\n        }\r\n    }\r\n}).bind(function (event, oldState, newState) {\r\n\r\n    var transition = oldState + ' => ' + newState;\r\n\r\n    switch (transition) {\r\n        /*\r\n        ...\r\n        case 'STOPPED => PLAYING':\r\n        case 'PLAYING => PAUSED':\r\n        ...\r\n        */\r\n        default:\r\n            console.log(transition);\r\n            break;\r\n    }\r\n});\r\n\r\nradio.play().pause().play().pause().stop();\r\n//STOPPED => PLAYING\r\n//PLAYING => PAUSED\r\n//PAUSED => PLAYING\r\n//PLAYING => PAUSED\r\n//PAUSED => STOPPED\r\n```\r\n\r\n### Radio (more declarative)\r\n\r\n```js\r\nvar radio = Stately.machine({\r\n    'STOPPED': {\r\n        'play': /* => */ 'PLAYING'\r\n    },\r\n    'PLAYING': {\r\n        'stop':  /* => */ 'STOPPED',\r\n        'pause': /* => */ 'PAUSED'\r\n    },\r\n    'PAUSED': {\r\n        'play': /* => */ 'PLAYING',\r\n        'stop': /* => */ 'STOPPED'\r\n    }\r\n});\r\n\r\nradio.onleaveSTOPPED = function (event, oldState, newState) {\r\n    // ...\r\n};\r\n\r\nradio.onenterSTOPPED = function (event, oldState, newState) {\r\n    // ...\r\n};\r\n\r\nradio.onPLAYING = function (event, oldState, newState) {\r\n    // ...\r\n};\r\n\r\nradio.onPAUSED = function (event, oldState, newState) {\r\n    // ...\r\n};\r\n```\r\n\r\n## jsFiddles\r\n* http://jsfiddle.net/sz2hG/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}